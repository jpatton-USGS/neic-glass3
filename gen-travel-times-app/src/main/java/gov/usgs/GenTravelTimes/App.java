/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package gov.usgs.GenTravelTimes;

import gov.usgs.traveltime.*;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.Arrays;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Level;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

public class App {
  /** The current version of station-lookup */
  public static final String VERSION = "v0.1.0";

  /** A String containing the definition of an empty string for config file parsing. */
  private static final String EMPTY_STRING = "";

  /** A String containing the definition the comment line identifier for config file parsing. */
  private static final String COMMENT_IDENTIFIER = "#";

  /** A double value used to signify that there was no valid travel time */
  private static final Double INVALID_TRAVEL_TIME = -10.0;

  /** A String value used to signify that there was no valid phase */
  private static final String INVALID_PHASE = "";

  /** A String containing the argument for specifying the config file. */
  public static final String MODE_CONFIGFILE = "--configFile=";

  /** A String containing the argument for specifying the log configuration file path. */
  public static final String LOGCONFIG_ARGUMENT = "--logConfig=";

  /** Log4J logger */
  static Logger logger = Logger.getLogger(App.class);

  public static void main(String[] args) {
    if (args == null || args.length == 0) {
      System.out.println(
          "Usage: \n\tgen-glass-ttt --configFile='file path' " + "[--logConfig='file path']");
      System.exit(1);
    }

    // defaults
    String configPath = null;
    String logConfigPath = null;
    String fileType = "TRAV";

    // process arguments
    StringBuffer argumentList = new StringBuffer();
    for (String arg : args) {
      // save arguments for logging
      argumentList.append(arg).append(" ");

      if (arg.startsWith(MODE_CONFIGFILE)) {
        // get mode
        configPath = arg.replace(MODE_CONFIGFILE, "");
      } else if (arg.startsWith(LOGCONFIG_ARGUMENT)) {
        // get kafka output config path
        logConfigPath = arg.replace(LOGCONFIG_ARGUMENT, "");
      }
    }

    // setup log4j
    if ((logConfigPath != null) && (!"".equals(logConfigPath))) {
      System.out.println("Using custom logging configuration");
      PropertyConfigurator.configure(logConfigPath);
    } else {
      System.out.println("Using default logging configuration");
      BasicConfigurator.configure();
      LogManager.getRootLogger().setLevel(Level.INFO);
    }

    // get config from file
    JSONObject configuration = readConfigurationFromFile(configPath);
    if (configuration == null) {
      logger.error("Configuration is null, exitting.");
      System.exit(1);
    }

    // travel time package configuration values, make configurable?
    boolean readPhaseStats = true;
    boolean readEllipticity = true;
    boolean readTopography = true;
    boolean returnAllPhases = true; // all phase return
    boolean returnBackBranches = true; // Return back branches
    boolean rstt = false; // always false, not implemented
    boolean tectonic = true; // source is a tectonic province
    double elev = 0.0d;

    // get the location of the model files
    String modelPath = "./models/";
    if (configuration.containsKey("EarthModelPath")) {
      modelPath = (String) configuration.get("EarthModelPath");
    }

    // get the extension
    String fileExtension = ".trv";
    if (configuration.containsKey("FileExtension")) {
      fileExtension = (String) configuration.get("FileExtension");
    }

    // get the output file
    String outputPath = "./";
    if (configuration.containsKey("OutputPath")) {
      outputPath = (String) configuration.get("OutputPath");
    }

    // whetehr to generate debug file
    boolean writeDebugFile = false;
    if (configuration.containsKey("WriteDebugFile")) {
      writeDebugFile = (boolean) configuration.get("WriteDebugFile");
    }

    // get branches
    JSONArray branchArray = null;
    if (configuration.containsKey("Branches")) {
      branchArray = (JSONArray) configuration.get("Branches");
    } else {
      logger.error("Missing required configuration key Branches, exitting.");
      System.exit(1);
    }

    // if we had any branches
    if ((branchArray != null) && (!branchArray.isEmpty())) {
      // go through the whole array
      for (int i = 0; i < branchArray.size(); i++) {
        JSONObject branchConfig = (JSONObject) branchArray.get(i);

        // get branch name
        String branchName = null;
        if (branchConfig.containsKey("BranchName")) {
          branchName = (String) branchConfig.get("BranchName");
        } else {
          logger.error("Missing required configuration key BranchName, exitting.");
          System.exit(1);
        }

        // get file name
        String fileName = null;
        if (branchConfig.containsKey("FileName")) {
          fileName = (String) branchConfig.get("FileName");
        } else {
          // default to branch name if not specified
          fileName = branchName;
        }

        // get earth model
        String earthModel = "ak135";
        if (branchConfig.containsKey("EarthModel")) {
          earthModel = (String) branchConfig.get("EarthModel");
        }

        // get phase list
        String[] phaseList = null;
        String phaseString = "";
        if (branchConfig.containsKey("PhaseList")) {
          JSONArray phaseArray = (JSONArray) branchConfig.get("PhaseList");

          if ((phaseArray != null) && (!phaseArray.isEmpty())) {
            phaseList = new String[phaseArray.size()];

            // go through the whole array
            for (int j = 0; j < phaseArray.size(); j++) {
              // add to list
              phaseList[j] = (String) phaseArray.get(j);

              // add to string (for file)
              if (j > 0) {
                // comma delimit
                phaseString += ",";
              }
              phaseString += (String) phaseArray.get(j);
            }
          }
        } else {
          logger.error("Missing required configuration key PhaseList, exitting.");
          System.exit(1);
        }

        // get min distance
        Double minimumDistance = null;
        if (branchConfig.containsKey("MinimumDistance")) {
          minimumDistance = (double) branchConfig.get("MinimumDistance");
        } else {
          logger.error("Missing required configuration key MinimumDistance, exitting.");
          System.exit(1);
        }

        // get max distance
        Double maximumDistance = null;
        if (branchConfig.containsKey("MaximumDistance")) {
          maximumDistance = (double) branchConfig.get("MaximumDistance");
        } else {
          logger.error("Missing required configuration key MaximumDistance, exitting.");
          System.exit(1);
        }

        // get number of distances
        Integer numberOfDistances = null;
        if (branchConfig.containsKey("NumberOfDistances")) {
          numberOfDistances = ((Long) branchConfig.get("NumberOfDistances")).intValue();
        } else {
          logger.error("Missing required configuration key NumberOfDistances, exitting.");
          System.exit(1);
        }

        // get min depth
        Double minimumDepth = null;
        if (branchConfig.containsKey("MinimumDepth")) {
          minimumDepth = (double) branchConfig.get("MinimumDepth");
        } else {
          logger.error("Missing required configuration key MinimumDepth, exitting.");
          System.exit(1);
        }

        // get max depth
        Double maximumDepth = null;
        if (branchConfig.containsKey("MaximumDepth")) {
          maximumDepth = (double) branchConfig.get("MaximumDepth");
        } else {
          logger.error("Missing required configuration key MaximumDepth, exitting.");
          System.exit(1);
        }

        // get number of depths
        Integer numberOfDepths = null;
        if (branchConfig.containsKey("NumberOfDepths")) {
          numberOfDepths = ((Long) branchConfig.get("NumberOfDepths")).intValue();
        } else {
          logger.error("Missing required configuration key NumberOfDepths, exitting.");
          System.exit(1);
        }

        // calculate steps
        Double distanceStep = (maximumDistance - minimumDistance) / (double) numberOfDistances;
        Double depthStep = (maximumDepth - minimumDepth) / (double) numberOfDepths;

        logger.info(
            "Generating ttt file: "
                + "\nFile Name: \n\t"
                + outputPath
                + "/"
                + fileName
                + fileExtension
                + "\nBranch Name: \n\t"
                + branchName
                + "\nPhases: \n\t"
                + phaseString
                + "\nDistance parameters: "
                + "\n\tMinDist: "
                + String.valueOf(minimumDistance)
                + "\n\tMaxDist: "
                + String.valueOf(maximumDistance)
                + "\n\tNumDist: "
                + String.valueOf(numberOfDistances)
                + "\n\t(Calculated) DistStep: "
                + String.valueOf(distanceStep)
                + "\nDepth parameters: "
                + "\n\tMinDepth: "
                + String.valueOf(minimumDepth)
                + "\n\tMaxDepth: "
                + String.valueOf(maximumDepth)
                + "\n\tNumDepth: "
                + String.valueOf(numberOfDepths)
                + "\n\t(Calculated) DepthStep: "
                + String.valueOf(depthStep));

        // Initialize the local travel-time manager and setup the current model
        TTSessionLocal ttLocal = null;
        try {
          ttLocal = new TTSessionLocal(readPhaseStats, readEllipticity, readTopography, modelPath);
        } catch (IOException e) {
          System.out.println("Unable to read travel-time auxiliary data.");
        }

        ArrayList travelTimeArray = new ArrayList<Double>();
        ArrayList travelTimeRows = new ArrayList<String>();

        // calculate travel time interpolation array
        // for each depth
        for (int depthCount = 0; depthCount < numberOfDepths; depthCount++) {
          // compute current depth
          Double currentDepth = minimumDepth + (depthStep * depthCount);

          // Set up a session for this depth
          try {
            ttLocal.newSession(
                earthModel,
                currentDepth,
                phaseList,
                returnAllPhases,
                returnBackBranches,
                tectonic,
                rstt);

          } catch (Exception e) {
            System.out.println("Session setup failed");
            System.exit(1);
          }

          // calculate travel time interpolation row for this depth
          String rowString = "";
          for (int distanceCount = 0; distanceCount < numberOfDistances; distanceCount++) {
            // compute current distance
            Double currentDistance = minimumDistance + (distanceStep * distanceCount);

            // init to defaults
            Double rowEntry = INVALID_TRAVEL_TIME;
            String rowPhase = INVALID_PHASE;

            // get the best travel time
            TTimeData phase = getBestPhase(ttLocal.getTT(elev, currentDistance), phaseList);

            // is the phase valid and positive
            if ((phase != null) && (phase.getTT() >= 0)) {
              // round travel time to 5 decimals
              rowEntry = Math.floor(phase.getTT() * 100000) / 100000;

              // if the row entry is less than or equal to zero, use the
              // default "no data" indicator
              if (rowEntry <= 0) {
                rowEntry = 0.0; // INVALID_TRAVEL_TIME;
              }

              // remember the phase used to generate the tt file (for debug file)
              rowPhase = phase.getPhCode();
            } else {
              // no valid travel time
              rowEntry = INVALID_TRAVEL_TIME;
              rowPhase = INVALID_PHASE;
            }

            // add the phase travel time to the list
            travelTimeArray.add(rowEntry);

            // add to string (for debug file)
            if (distanceCount > 0) {
              // comma delimit
              rowString += ",";
            }
            rowString +=
                String.format("%.2f", currentDepth)
                    + ":"
                    + String.format("%.2f", currentDistance)
                    + ":"
                    + String.valueOf(rowEntry)
                    + ":"
                    + rowPhase;
          }

          // add this row string to list of row strings (for debug file)
          travelTimeRows.add(rowString);
        }

        logger.info(branchName + " travelTimeArray Generated, Writing file");

        // we should have everything we need now, so now write the binary travel
        // time file to disk
        try {
          // A travel time file is a binary file with a header and the travel time
          //     interpolation array
          // The file consists of the following:
          // <SOF>
          // <FileType> - 4 ascii characters plus null termination - 5 bytes
          // <BranchName> - 16 ascii characters plus null termination - 17 bytes
          // <PhaseList> - 64 ascii characters plus null termination - 65 bytes
          // <numberOfDistancePoints> - 1 int value, 4 bytes
          // <minimumDistance> - 1 double value, 8 bytes
          // <maximumDistance> - 1 double value, 8 bytes
          // <numberOfDepthPoints> - 1 int value, 4 bytes
          // <minimumDepth> - 1 double value, 8 bytes
          // <maximumDepth> - 1 double value, 8 bytes
          // <travelTimeInterpolationArray> -
          //    (numberOfDistancePoints * numberOfDepthPoints) double values,
          //    (numberOfDistancePoints * numberOfDepthPoints) * 8 bytes
          // <EOF>

          // create binary capable output stream
          DataOutputStream outputFile =
              new DataOutputStream(
                  new BufferedOutputStream(
                      new FileOutputStream(outputPath + "/" + fileName + fileExtension)));

          // write header values
          // File type is a character array of 4 ascii characters plus null termination
          outputFile.write(getCStringBytes(fileType), 0, 5);

          // branch name is a character array of 16 ascii characters plus null termination
          outputFile.write(getCStringBytes(padRight(branchName, 16)), 0, 17);

          // The phase list is a character array of 64 ascii characters plus null termination
          outputFile.write(getCStringBytes(padRight(phaseString, 64)), 0, 65);

          // write number of distance points, 1 int, 4 bytes
          outputFile.write(getCIntBytes(numberOfDistances.intValue()), 0, Integer.BYTES);

          // write the minimum distance, 1 double, 8 bytes
          outputFile.write(getCDoubleBytes(minimumDistance.doubleValue()), 0, Double.BYTES);

          // write the maximum distance, 1 double, 8 bytes
          outputFile.write(getCDoubleBytes(maximumDistance.doubleValue()), 0, Double.BYTES);

          // write number of depth points, 1 int, 4 bytes
          outputFile.write(getCIntBytes(numberOfDepths.intValue()), 0, Integer.BYTES);

          // write the minimum depth, 1 double, 8 bytes
          outputFile.write(getCDoubleBytes(minimumDepth.doubleValue()), 0, Double.BYTES);

          // write the maximum depth, 1 double, 8 bytes
          outputFile.write(getCDoubleBytes(maximumDepth.doubleValue()), 0, Double.BYTES);

          // write travel time interpolation array,
          //   (numberOfDistances * numberOfDepths) doubles,
          //   (numberOfDistances * numberOfDepths * 8) bytes
          outputFile.write(
              getCDoubleArrayBytes(travelTimeArray),
              0,
              (Double.BYTES * numberOfDistances * numberOfDepths));

          // done with file
          outputFile.close();
        } catch (FileNotFoundException e) {
          logger.error(e.toString());
          continue;
        } catch (IOException e) {
          logger.error(e.toString());
          continue;
        }

        // write a debug (ascii) tt file if asked
        if (writeDebugFile) {
          try {
            // create a ascii file
            PrintWriter fileWriter = new PrintWriter(outputPath + "/" + fileName + ".txt", "UTF-8");

            // write header values
            // File type
            fileWriter.println(fileType);

            // branch name
            fileWriter.println(padRight(branchName, 16));

            // The phase list
            fileWriter.println(padRight(phaseString, 16));

            // write number of distance points
            fileWriter.println(numberOfDistances);

            // write the minimum distance
            fileWriter.println(minimumDistance);

            // write the maximum distance
            fileWriter.println(maximumDistance);

            // write number of depth points
            fileWriter.println(numberOfDepths);

            // write the minimum depth
            fileWriter.println(minimumDepth);

            // write the maximum depth
            fileWriter.println(maximumDepth);

            // write travel time interpolation array
            for (Object row : travelTimeRows) {
              fileWriter.println((String) row);
            }
            fileWriter.println();

            // done with file
            fileWriter.flush();
            fileWriter.close();
          } catch (Exception e) {

            // log exception
            logger.error(e.toString());
          }
        }
        logger.info(branchName + " File Written");
      }
    }
  }

  /**
   * This method to gets the "best" (for now earliest) TTimeData from a given TTime entry, ensuring
   * that the entry used is in the given phase list filter
   *
   * @param ttEntry a TTime containing the travel time entry to use
   * @param commentIdentifier a String[] containing the phase name filter list
   * @return a TTimeData containing the "best" travel time data entry, or null if one is not found
   */
  public static TTimeData getBestPhase(TTime ttEntry, String[] phaseList) {
    // nullchecks
    if (ttEntry == null) {
      return null;
    }
    if (ttEntry.getNumPhases() == 0) {
      return null;
    }

    // if we don't have a phase name filter list, return the first (earliest)
    // phase
    if (phaseList == null) {
      return ttEntry.getPhase(0);
    }

    // go through each phase in the entry
    for (int i = 0; i < ttEntry.getNumPhases(); i++) {
      TTimeData aPhase = ttEntry.getPhase(i);

      // return the first (earliest) phase in the phase list
      // that matches the phase list filter, we do this because
      // certain phases (like P) are generic and return more than one
      // phase.
      if (Arrays.asList(phaseList).contains(aPhase.getPhCode())) {
        return (aPhase);
      }
    }

    // we didn't get a valid phase
    return null;
  }

  /**
   * This method converts the provided integer into the equivalent bytes which are readable by a
   * C/C++ program
   *
   * @param value an integer containing the number to convert
   * @return a byte[] containing the equivalent bytes
   */
  public static byte[] getCIntBytes(int value) {
    // Create the ByteBuffer and init the byte order to the native byte order (rather than the
    // java default). We do this to ensure that the integer is readable by
    // a c/c++ program.
    ByteBuffer buffer = ByteBuffer.allocate(Integer.BYTES).order(ByteOrder.nativeOrder());

    // write the int to bytes
    buffer.putInt(value);

    // return the bytes
    return (buffer.array());
  }

  /**
   * This method converts the provided double into the equivalent bytes which are readable by a
   * C/C++ program
   *
   * @param value an double containing the number to convert
   * @return a byte[] containing the equivalent bytes
   */
  public static byte[] getCDoubleBytes(double value) {
    // Create the ByteBuffer and init the byte order to the native byte order (rather than the
    // java default). We do this to ensure that the double is readable by
    // a c/c++ program.
    ByteBuffer buffer = ByteBuffer.allocate(Double.BYTES).order(ByteOrder.nativeOrder());

    // write the double to bytes
    buffer.putDouble(value);

    // return the bytes
    return (buffer.array());
  }

  /**
   * This method converts the provided ArrayList of doubles into the equivalent bytes which are
   * readable by a C/C++ program
   *
   * @param value an double containing the number to convert
   * @return a byte[] containing the equivalent bytes
   */
  public static byte[] getCDoubleArrayBytes(ArrayList<Double> data) {
    // nullcheck
    if (data == null) {
      return null;
    }

    // allocate a byte array of the proper size
    byte[] bytes = new byte[data.size() * Double.BYTES];

    // for each element in the ArrayList
    for (int i = 0; i < data.size(); i++) {
      // Convert the double to bytes
      byte[] doubleBytes = getCDoubleBytes((double) data.get(i));

      // copy the bytes into the byte array
      System.arraycopy(doubleBytes, 0, bytes, (i * Double.BYTES), Double.BYTES);
    }

    // return the bytes
    return bytes;
  }

  /**
   * This method converts the provided String into the equivalent bytes which are readable by a
   * C/C++ program
   *
   * @param s a String containing the string to convert
   * @return a byte[] containing the equivalent bytes
   */
  public static byte[] getCStringBytes(String s) {
    try {
      // Create a byte[] from the string with the appropriate character byte
      // size for c characters. We do this because by default java uses unicode
      // (two bytes) as opposed to c/c++ (one byte)
      byte[] stringBytes = s.getBytes("ISO-8859-1");

      // null terminate the byte string array (java doesn't null terminate strings)
      byte[] ntBytes = new byte[stringBytes.length + 1];
      System.arraycopy(stringBytes, 0, ntBytes, 0, stringBytes.length);

      // return the bytes
      return ntBytes;
    } catch (UnsupportedEncodingException e) {
      logger.error(e);
      return null;
    }
  }

  /**
   * This method pads to the right the provided string with the designated number of spaces
   *
   * @param s a String containing the string to pad
   * @param n an Integer containing the number of spaces to pad
   * @return a String containing the padded string
   */
  public static String padRight(String s, int n) {
    return String.format("%-" + n + "s", s);
  }

  /**
   * Convenience to read a json formatted configuration file identified by the given configuration
   * file name.
   *
   * @param configFileName a String containing the configuration file name.
   * @return a JSONObject containing the configuration
   */
  public static JSONObject readConfigurationFromFile(final String configFileName) {

    // read the config file
    File configFile = new File(configFileName);
    if (!configFile.exists()) {
      logger.error("Error, configuration file not found.");
      return (null);
    }

    // set up the reader, read the file
    BufferedReader configReader = null;
    StringBuffer configBuffer = new StringBuffer();
    try {
      configReader = new BufferedReader(new FileReader(configFile));
      String line = null;

      // while there are lines
      while ((line = configReader.readLine()) != null) {
        // strip any comments
        String strippedLine = stripCommentsFromLine(line, COMMENT_IDENTIFIER);

        // add line to buffer
        if (!line.isEmpty()) {
          configBuffer.append(strippedLine).append("\n");
        }
      }
    } catch (FileNotFoundException e) {
      e.printStackTrace();
    } catch (IOException e) {
      e.printStackTrace();
    } finally {
      try {
        if (configReader != null) {
          configReader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
    }

    // parse config file into json
    JSONObject configJSON = null;
    try {
      JSONParser configParser = new JSONParser();
      configJSON = (JSONObject) configParser.parse(configBuffer.toString());
    } catch (ParseException e) {
      e.printStackTrace();
    }

    return (configJSON);
  }

  /**
   * Convenience method to strip comments from a line from a configuration file identified by the
   * given comment identifier. This function will return any characters up to the comment identifier
   * and not return any characters after (and including) the comment identifier up to the end of
   * provided line string. This function will return an empty string if the line string starts with
   * a comment identifier.
   *
   * @param line a String containing the configuration line to strip.
   * @param commentIdentifier a String containing the comment identifier character/string
   * @return a String containing the line without comments.
   */
  public static String stripCommentsFromLine(String line, final String commentIdentifier) {

    // nullcheck
    if (line != null) {
      // empty checks
      if (line.isEmpty()) {
        return (line);
      }
      if (commentIdentifier.isEmpty()) {
        return (line);
      }

      // look for the comment identifier
      int position = line.indexOf(commentIdentifier);

      // check position
      if (position == 0) {
        // identifier found in the first position
        // the whole line is a comment
        // return none of this line
        return (EMPTY_STRING);
      } else if (position == -1) {
        // no identifier found
        // no part of the line is a comment,
        // return entire line
        return (line);
      } else {
        // found identifier somewhere in the line
        // everything after the identifier is a comment
        // everything before is the line
        // return the part of the line starting at 0
        // and going to position of the identifier
        return (line.substring(0, position));
      }
    }

    // return empty line (if null)
    return (EMPTY_STRING);
  }

  public String getGreeting() {
    return "Hello world.";
  }
}
